<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Understanding Paging: Flat vs. Hierarchical</title>
  <link rel="stylesheet" href="https://cdn.simplecss.org/simple.css" />
  <style>
    body {
      max-width: 900px;
      margin: 2rem auto;
      padding: 0 1rem;
      line-height: 1.6;
    }
    header, footer {
      text-align: center;
      margin-bottom: 2rem;
    }
    section {
      margin-bottom: 2.5rem;
    }
    pre, code {
      background: #f5f5f5;
      border-radius: 6px;
      padding: 0.3em 0.5em;
      font-size: 0.95em;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin: 1em 0;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 0.5em;
      text-align: center;
    }
    blockquote {
      border-left: 4px solid #555;
      padding-left: 1em;
      color: #333;
      background: #f8f8f8;
    }
    .back-home {
      display: inline-block;
      margin-top: 2rem;
      text-decoration: none;
      background: #0366d6;
      color: white;
      padding: 0.5em 1em;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Understanding Paging: Flat vs. Hierarchical Paging</h1>
    <p><em>A simple explanation for students, system programmers, and curious engineers.</em></p>
  </header>

  <section id="what-is-paging">
    <h2>What is Paging?</h2>
    <p>Paging is a <em>memory management technique</em> that breaks physical and virtual memory into fixed-size blocks called <strong>pages</strong>. It allows an operating system to:</p>
    <ul>
      <li>Use memory more efficiently,</li>
      <li>Avoid external fragmentation,</li>
      <li>Isolate processes in their own address spaces.</li>
    </ul>
    <p>Each process uses <strong>virtual addresses</strong>, which must be translated into physical addresses before accessing RAM. This translation is done by the <strong>MMU (Memory Management Unit)</strong> using <strong>page tables</strong>.</p>
  </section>

  <section id="flat-paging">
    <h2>Flat (Single-Level) Paging</h2>
    <p>In <strong>flat paging</strong>, the system uses a <strong>single page table</strong> to map virtual pages directly to physical frames.</p>
    <h3>Example</h3>
    <ul>
      <li>If a system uses 4 KB pages and 32-bit virtual addresses:</li>
      <li>There are $2^{32}/2^{12}$ = $2^{20}$ = 1,048,576 virtual pages.</li>
      <li>Each entry holds the physical frame number and flags (valid, dirty, accessed).</li>
    </ul>
    <h3>Problem</h3>
    <ul>
      <li>1,048,576 entries × 4 bytes = <strong>4 MB per process</strong>.</li>
      <li>For 100 processes → <strong>400 MB</strong> only for page tables!</li>
    </ul>
    <blockquote>Flat paging doesn’t scale well as address spaces and process counts grow.</blockquote>
  </section>

  <section id="hierarchical-paging">
    <h2>Hierarchical (Multi-Level) Paging</h2>
    <p>To solve the memory overhead problem, modern systems use <strong>hierarchical paging</strong> — breaking the page table into smaller parts that can be loaded on demand.</p>

    <h3>Example: 2-Level Paging (32-bit System)</h3>
    <table>
      <thead>
        <tr><th>Field</th><th>Bits</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr><td>Dir</td><td>10</td><td>Page Directory Index</td></tr>
        <tr><td>Tbl</td><td>10</td><td>Page Table Index</td></tr>
        <tr><td>Offset</td><td>12</td><td>Offset within Page</td></tr>
      </tbody>
    </table>

    <ul>
      <li><strong>Page Directory (Dir)</strong> points to <strong>Page Tables (Tbl)</strong>.</li>
      <li>Only necessary parts of the table stay in memory.</li>
    </ul>

    <h3>Advantages</h3>
    <ul>
      <li>Saves memory — page tables created only when needed.</li>
      <li>Easier to manage large address spaces.</li>
      <li>Supports demand paging and TLB caching.</li>
    </ul>

    <h3>Disadvantages</h3>
    <ul>
      <li>More lookups — increases translation time.</li>
      <li>Requires MMU and TLB support.</li>
    </ul>
  </section>

  <section id="x86-example">
    <h2>Real-World Example: x86-64 (4-Level Paging)</h2>
    <p>Modern 64-bit CPUs (Intel, AMD) use 4 or 5 levels of paging, typically for 48-bit virtual addresses.</p>
    <table>
      <thead>
        <tr><th>PML4</th><th>PDPT</th><th>PD</th><th>PT</th><th>Offset</th></tr>
      </thead>
      <tbody>
        <tr><td>9 bits</td><td>9 bits</td><td>9 bits</td><td>9 bits</td><td>12 bits</td></tr>
      </tbody>
    </table>
    <p>Each level indexes 9 bits of the virtual address. Although translation takes multiple memory accesses, the <strong>TLB (Translation Lookaside Buffer)</strong> caches these mappings efficiently.</p>
  </section>

  <section id="summary">
    <h2>Summary</h2>
    <table>
      <thead>
        <tr><th>Feature</th><th>Flat Paging</th><th>Hierarchical Paging</th></tr>
      </thead>
      <tbody>
        <tr><td>Structure</td><td>Single table</td><td>Multi-level tables</td></tr>
        <tr><td>Memory Use</td><td>High</td><td>Low</td></tr>
        <tr><td>Translation</td><td>Single lookup</td><td>2–5 lookups</td></tr>
        <tr><td>Performance</td><td>Fast (simple)</td><td>Slower per access, TLB optimized</td></tr>
        <tr><td>Used In</td><td>Small systems</td><td>Modern CPUs</td></tr>
      </tbody>
    </table>

    <blockquote>
      <strong>Key Takeaway:</strong><br>
      Flat paging is simple but memory-hungry.<br>
      Hierarchical paging is complex but scalable — the foundation of modern virtual memory.
    </blockquote>
  </section>

  <section id="further-reading">
    <h3>Further Reading</h3>
    <ul>
      <li><em>Operating Systems: Three Easy Pieces</em> — Virtual Memory chapter</li>
      <li>Intel® SDM Vol. 3A, Chapter 4 (Paging)</li>
      <li><a href="https://wiki.osdev.org/Paging" target="_blank">Paging on x86_64 — OSDev Wiki</a></li>
    </ul>
  </section>

  <p><a class="back-home" href="index.html">← Back to Home</a></p>
  <footer>
    <p>© 2025 Your Name — Published on <a href="https://github.com/yourusername/yourusername.github.io">GitHub Pages</a></p>
  </footer>
</body>
</html>
